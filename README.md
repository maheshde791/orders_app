## main.py

The `main.py` file is a Python script that performs various calculations and generates output based on data from a CSV file. It uses the `csv` module for reading the CSV file and the `collections` module for creating defaultdicts.

### Functions

The script provides the following functions:

#### `calculate_monthly_revenue(data)`

This function calculates the total revenue generated by the online store for each month in the dataset. It takes the data as input, which is a list of dictionaries representing the CSV rows. It returns a defaultdict where the keys are the months (extracted from the 'order_date' field) and the values are the corresponding revenue.

#### `calculate_product_revenue(data)`

This function computes the total revenue generated by each product in the dataset. It takes the data as input and returns a defaultdict where the keys are the product IDs and the values are the total revenue for each product.

#### `calculate_customer_revenue(data)`

This function calculates the total revenue generated by each customer in the dataset. It takes the data as input and returns a defaultdict where the keys are the customer IDs and the values are the total revenue for each customer.

#### `identify_top_customers(customer_revenue, n=10)`

This function identifies the top customers by revenue generated. It takes the customer_revenue defaultdict as input, which contains the revenue for each customer, and an optional parameter `n` to specify the number of top customers to identify. It returns a list of tuples, where each tuple contains the customer ID and the corresponding revenue.

### Execution

The script follows these steps for execution:

1. Reads data from the CSV file specified as `orders.csv` and stores it in a list of dictionaries.
2. Calls `calculate_monthly_revenue()` to compute the total revenue generated by month and prints the results.
3. Calls `calculate_product_revenue()` to calculate the total revenue generated by each product and prints the results.
4. Calls `calculate_customer_revenue()` to determine the total revenue generated by each customer and prints the results.
5. Calls `identify_top_customers()` to identify the top 10 customers by revenue generated and prints the results.

## test.py

The `test.py` file is a Python script that contains unit tests for the revenue calculation functions in the `main.py` file. It uses the `unittest` module to define and run the tests. This file is present in tests directory.

### Test Cases

The script defines the following test cases:

#### `test_calculate_monthly_revenue()`

This test case verifies that the `calculate_monthly_revenue()` function correctly calculates the total revenue generated by month. It uses a test dataset consisting of three orders with different dates and quantities. The expected result is a dictionary with the expected revenue for each month.

#### `test_calculate_product_revenue()`

This test case ensures that the `calculate_product_revenue()` function accurately computes the total revenue generated by each product. It uses a test dataset with three orders, each for a different product. The expected result is a dictionary with the expected revenue for each product.

#### `test_calculate_customer_revenue()`

This test case checks if the `calculate_customer_revenue()` function correctly calculates the total revenue generated by each customer. It uses a test dataset with three orders, each associated with a different customer. The expected result is a dictionary with the expected revenue for each customer.

#### `test_identify_top_customers()`

This test case validates the `identify_top_customers()` function, which identifies the top customers by revenue generated. It uses a predefined customer revenue dictionary and expects the function to return a list of tuples with the top customers and their corresponding revenue.

#### `test_identify_top_customers_less_than_n()`

This test case examines the behavior of the `identify_top_customers()` function when the number of top customers requested is greater than the available customers. It expects the function to return all customers with their respective revenue.

## Dockerfile
Simply used python base image, set work directory to /app in containers and copy all project file into the same

## Execution
## docker-compose.yaml

The `docker-compose.yaml` file is used to define and configure the Docker services for the task application and the test suite. It follows the YAML syntax format and consists of two services: `task` and `test`.

### Service: task

The `task` service is responsible for running the main application code (`main.py`). It is built using the specified `Dockerfile` and sets the context to the current directory (`.`). The service also mounts the current directory to the `/app` directory inside the container, allowing the application code to be accessed. The command specified for this service is `python main.py`, which instructs the container to execute the `main.py` script.

### Service: test

The `test` service is dedicated to running the unit tests (`test.py`) for the application. It is also built using the specified `Dockerfile` and sets the context to the current directory (`.`). Similar to the `task` service, it mounts the current directory to the `/app` directory inside the container. The command specified for this service is `python -m unittest discover -s tests -p 'test.py'`. This command executes the unit tests using the `unittest` module, discovering test cases in the `tests` directory and matching files with the pattern `'test.py'`.

### Usage

To use the `docker-compose.yaml` file, make sure you have Docker and Docker Compose installed. Navigate to the directory containing the `docker-compose.yaml` file in your terminal or command prompt.

To start the task application, run the following command:

```bash
docker-compose up task
```

This will build the Docker image and run the `task` service, executing the `main.py` script inside the container.

To run the test suite, execute the following command:

```bash
docker-compose up test
```

This will build the Docker image and run the `test` service, executing the unit tests inside the container.
